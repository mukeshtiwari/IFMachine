package secc.c;

import java.util.Set;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short STAR = 1;
		static public final short INCR = 2;
		static public final short DECR = 3;
		static public final short PLUS = 4;
		static public final short MINUS = 5;
		static public final short AMP = 6;
		static public final short ID = 7;
		static public final short LPAREN = 8;
		static public final short FORALL = 9;
		static public final short OLD = 10;
		static public final short SIZEOF = 11;
		static public final short EXISTS = 12;
		static public final short PREFIX = 13;
		static public final short POSTFIX = 14;
		static public final short NUM = 15;
		static public final short BANG = 16;
		static public final short TILDE = 17;
		static public final short LBRACK = 18;
		static public final short DOT = 19;
		static public final short ARROW = 20;
		static public final short RPAREN = 21;
		static public final short DIV = 22;
		static public final short MOD = 23;
		static public final short AND = 24;
		static public final short SHL = 25;
		static public final short SHR = 26;
		static public final short GT = 27;
		static public final short COMMA = 28;
		static public final short LT = 29;
		static public final short LE = 30;
		static public final short GE = 31;
		static public final short EQ = 32;
		static public final short NEQ = 33;
		static public final short CARET = 34;
		static public final short PIPE = 35;
		static public final short DCOLON = 36;
		static public final short ASG = 37;
		static public final short OR = 38;
		static public final short IMP = 39;
		static public final short SEMICOLON = 40;
		static public final short QUESTION = 41;
		static public final short EQV = 42;
		static public final short ASG_OP = 43;
		static public final short STRUCT = 44;
		static public final short UNION = 45;
		static public final short ENUM = 46;
		static public final short MAP_LT = 47;
		static public final short LIST_LT = 48;
		static public final short VOID = 49;
		static public final short INT = 50;
		static public final short CHAR = 51;
		static public final short PARAM = 52;
		static public final short TYPE = 53;
		static public final short PRED = 54;
		static public final short LBRACE = 55;
		static public final short UNDERSCORE = 56;
		static public final short RBRACE = 57;
		static public final short WHILE = 58;
		static public final short FOR = 59;
		static public final short DO = 60;
		static public final short IF = 61;
		static public final short RETURN = 62;
		static public final short BREAK = 63;
		static public final short CONTINUE = 64;
		static public final short PTO = 65;
		static public final short RBRACK = 66;
		static public final short COLON = 67;
		static public final short LEMMA = 68;
		static public final short RELY = 69;
		static public final short STRING = 70;
		static public final short ATOMIC = 71;
		static public final short TYPEDEF = 72;
		static public final short APPLY = 73;
		static public final short INDUCT = 74;
		static public final short SHARED = 75;
		static public final short GUARANTEE = 76;
		static public final short ASSERT = 77;
		static public final short BEGIN = 78;
		static public final short END = 79;
		static public final short FAILS = 80;
		static public final short ELSE = 81;
		static public final short PRUNE = 82;
		static public final short ASSUME = 83;
		static public final short UNFOLD = 84;
		static public final short FOLD = 85;
		static public final short REWRITES = 86;
		static public final short AXIOMS = 87;
		static public final short CONSTANT = 88;
		static public final short FUNCTION = 89;
		static public final short PREDICATE = 90;
		static public final short REQUIRES = 91;
		static public final short ENSURES = 92;
		static public final short INVARIANT = 93;
		static public final short RESOURCE = 94;
		static public final short MAINTAINS = 95;
		static public final short PURE = 96;
		static public final short COLONEQ = 97;

		static public final String[] NAMES = {
			"EOF",
			"STAR",
			"INCR",
			"DECR",
			"PLUS",
			"MINUS",
			"AMP",
			"ID",
			"LPAREN",
			"FORALL",
			"OLD",
			"SIZEOF",
			"EXISTS",
			"PREFIX",
			"POSTFIX",
			"NUM",
			"BANG",
			"TILDE",
			"LBRACK",
			"DOT",
			"ARROW",
			"RPAREN",
			"DIV",
			"MOD",
			"AND",
			"SHL",
			"SHR",
			"GT",
			"COMMA",
			"LT",
			"LE",
			"GE",
			"EQ",
			"NEQ",
			"CARET",
			"PIPE",
			"DCOLON",
			"ASG",
			"OR",
			"IMP",
			"SEMICOLON",
			"QUESTION",
			"EQV",
			"ASG_OP",
			"STRUCT",
			"UNION",
			"ENUM",
			"MAP_LT",
			"LIST_LT",
			"VOID",
			"INT",
			"CHAR",
			"PARAM",
			"TYPE",
			"PRED",
			"LBRACE",
			"UNDERSCORE",
			"RBRACE",
			"WHILE",
			"FOR",
			"DO",
			"IF",
			"RETURN",
			"BREAK",
			"CONTINUE",
			"PTO",
			"RBRACK",
			"COLON",
			"LEMMA",
			"RELY",
			"STRING",
			"ATOMIC",
			"TYPEDEF",
			"APPLY",
			"INDUCT",
			"SHARED",
			"GUARANTEE",
			"ASSERT",
			"BEGIN",
			"END",
			"FAILS",
			"ELSE",
			"PRUNE",
			"ASSUME",
			"UNFOLD",
			"FOLD",
			"REWRITES",
			"AXIOMS",
			"CONSTANT",
			"FUNCTION",
			"PREDICATE",
			"REQUIRES",
			"ENSURES",
			"INVARIANT",
			"RESOURCE",
			"MAINTAINS",
			"PURE",
			"COLONEQ"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjN0cSLCNHhzgvTrbOO6TTPGLD0auG4Gs11GMvaKjkH6vcbrjOaEM#5jWrWlSPHHGF44G" +
		"K5L63g36UKQE9AAXue44HhnWJZOBQ#Rz#jJFlpRpTUOEiVbz#E$EhLzNTrV#ghgxkrxsC4j" +
		"MlImjf1isa2wYK5jDOEe#MqaIQIW$IkJIS9j1Sca#7gGxLfMnNcafhhgLhQ0FTHQlfTtGvN" +
		"K5NqbLqDTt8Vkwa$i8dSMi#XHjp3kTodfEcEgmrNqpGJ6q$jSPkhilvD9vzt9GxKX457JtT" +
		"mtuQGQDgmFwJT9YzHeouARr0e#X59$lS0$RhKMuDs3$C7csz9#pdKGurT1n$7ko7wSqQiN#" +
		"opf1tO7ydvOASx4TX$pMkdxRzmxpMPQQkWFt7Q3czxMZ$Zx3$BEMapbIg3yrhwOuZyFH6bv" +
		"vke#je8nr7zpZQtuALSZLVwyBJly3JhKavzKiwXlBfrtGoTN3iTJSTJuteMBgVcj99r9rEe" +
		"LEfBGsbq#Wtz5jgHsVGMTIPkj90waczg83wKHyQhDTO7W#cFsEDfRBGH2oCD2oeLTLQU9GU" +
		"eSSD2$GtQaolOFsUa1B$2HEVfxWP0KyrHv0IDLUyFj5LNBP9NEwXNwL4$bgGV#4AkJp9tmV" +
		"eOPkD2Yh3TxIWDjEe$QqnJsaZrsLC8eBgAjBqd4lKve8wtTNytUOITPjanNskV6qXg2sn5b" +
		"CWyopnzsbN$f8Wvs4dt4T$vP8ulbv5PNmJlPwmYapyxpH#be7F6#aRgJtaQZojN4RfT47Tw" +
		"0hr1vUehGMrZQi8rNE9MYYexLsXDdI9UgQWTdI5UhnBr4wIVUvsZoukKRi9QdDNg6iTKFDe" +
		"C$sTrj0Ake5#JpjGNaOV2khfFmhreA1kqgWFqLSIrnwkujes6PM7ymgynOqrieERqSjO8sL" +
		"S9hwwsZkvdOElPrFlE2fV3zI#T8wW$ieLwXaEgF2Kti38T$2vl8ZUem5uSyaRH9N#cBXoTp" +
		"EklDw8Ar$8lGNrWYDyUtIWGJI4tj8H68QuLkXJyXY9G0kDUacAT$HQyntD6JRSpLGilju9N" +
		"$VpQfm#Az#YJxYARDJ1st4qsJ9Vbt577aUJnDkMhcAmqo6tHl5YEa1x4PzS#XZZBmFFbCYk" +
		"ifrJAf9GT#eOEBqPHj8qMgU#ji#XciFzjFzFS3ErYZkgLS0s$UzWMEBPrKUR9vhHLhDjkEN" +
		"SYFlm5ZuEdg$aStWSBqc8TaKAt2B1$RlTNnx80v1vkLoX5lEzV3kaiUdC8ftlbCaydozI2w" +
		"c4PW7lOk3Fvai4jSnLRinDHbLp#NBjwHKqHytd6$GipdD2PQx2rmKEkL7akFUQg5jjg1EgG" +
		"5taWBgLbj25T14oxcAwb6wcwzM$wIOdL8UCCr5lSK2zdswbs#bEeAwd#$2zbxRJROBw1rUe" +
		"VtAOhQVe6KGo5wYlulafVKR$u6C5zJ#kKF$fW5fE$w9lwNli2Zby0JVWe7g1mx8IZd6HiRs" +
		"um0cLJ#0c$4kEyAzv0P1RyMbygg3#nXNgRmNLVbDxNcvgByLlQjo62xbzQhsKx$5TujzPjc" +
		"mwCyc$NTg$pjg$bFT87iHTq$EDpwuwqtcOpRSXphxPq4RmUJoQnsD69lCqFf#dyqmk5RI5A" +
		"R9cLHBQF5xAL$9oNgcMyZLy7MPsdTelQ1jiQA4aD7j#R2Q$saTUNiEtK81ywbsi4tEdVzkM" +
		"7pdLuQXtw3x#7La$PI1pJP368OdLgWGSgpUMZte$9bfHoWLbamt5VjyZzPxDayli67otZ8W" +
		"i6Aap0nykLqjSh8DBjV#B7BE7a1dapXhjKlFSPgnQ86CruX2FXcdD6ZzJTfWNQAOJZQEXON" +
		"YvA#6#Hrm7rD4oxxjiSvSjyvybtkeu$Jp#KkB7mTzOTEbdyrT$U99#NWKQQew0krNworsu5" +
		"$Vb$Zo6Yta6p#5b2IFugVmrOvCSNtkDKtn$hBz7zhTSfxayCgHQZLgDMerQZLgDMerQZVyH" +
		"3VLzqjcbycxpNTAfqNgQSRut4ArJN#bJtAry1pkqSwUgM$I9x#QgpgvegVGY7M##FeAsptN" +
		"RbzeFed$7NFWauVHl#j60tgNtwGFwYBx0FPPm#ZVz$NtCyqpz3740p0zfcqR6FHPbZvOpn9" +
		"PnI#eUGpRhhBUXof5RPuNHsqDUeFc16OGFcPH5TIYRwb8zt8ZhqnJC#JGwFmtD8cg1kBP4P" +
		"5lXJd0wRWMjSI#OWJj28UvUxN7xEXEts8wurNPor2H7pTJsKsk4AGhlmiZU24sY0ZoTx4TW" +
		"tz0x#lORn68KqHQA7Us7ONyAPk$esw#qtaFRBwp2VXJsYw5HS$R3sdu#oCb#2UoN785zzvb" +
		"QfErFh7RyXIuoDGZD0Burv#aiM31ip76q7q3RETJVXQT6JXLKcrDElTeYOnjIBjPYdjvFZg" +
		"NZi6iKOEzeJ4te13gHVe4Tr$XNisROJGFOTvjZvpKoEuerLemrbif25x4GTcKX7BCG1Ne1Z" +
		"K#9tpaj$8ZWfqBD5zIeAzHPWZe7#gcGkmjo5rV8dEHlGtojDXgWRm56R$MtQrenoNSPasXQ" +
		"g5rh13NW4dMMeCvnXHgDPLtRbCX5QSrVq9RF3Mc51TzOHGLOHIK9gyZ4Rwhn8ne$G7tJYb8" +
		"qpTYtFQfh9vhMslbVHgsPsNA7MkI06iKPhHWd$YAS#MVZxHYboIZN9EgHnxKXBT9lcI8WJW" +
		"2YSPeh5zJfHumQbNTN73KQY#kHenRfC#T4V2VZQvn12s9la9zpjfBV7cO4mh4tU0CTLti42" +
		"bpw6h7XpW1AtDSmV2sCnQ1pMkz#AsemQRuYg4jdlfnMLrX$Ir2N3rwWPolW6Da6IQXHZUfy" +
		"gWtgMuqzsc7CcU5$P$ZV5VvtnzdSwdzJbr49st0PhM7u7D6U6wVjfWdHRk0oBX57V$Fn3Ek" +
		"JQJxDIsiMdU9jteJ2ElVoXLTcSe4hr9LLpABfQLJB1Vg#uOGQJijNfxbrGfsN1cexr7P155" +
		"Zl5H6KsyKohY15njbF4dPK4ujrBWHmwed6KAEkK9qZO4Gr7tL1oQvmcgXEAvbbtWln3O0R4" +
		"OW8QYIjZBMZHk7bGBrF181iyFPfeJh5rVcc5jNVz6x9JhdKnkPVrJdQnk9VQgjB4tQ8rBw5" +
		"gydqa2lVx3jrGC#mCIEz9MigLsCmHTOqIa8Bw$aCesTG8nNgJ7UwgnObeTdpensLekTSK80" +
		"Mq4BDdVAZi5eSerTOMJvK0D8uuC31qyI99E1OK6pz8p79WW9j4wMj3SLsEx3srVqR9M2qDJ" +
		"5GYcEap0oD57QLGn7HTSWUrBS1kRFM9esCbTXhETP7h5d7RiwiqxoqIISQHqN3Q6zZl#$1c" +
		"mcWIV5vhzmDnFzIyNQ#wQt4wMVnLoLydFojZ6vbhltq$efltVIp9wYNzEmNytSG3QOXD9I6" +
		"wN$NE8z698pW9$8tCJQnkDfg7EFxVyBV6ftBMerQZLgDMerQZLgDMet$7ngKU7Q9dMWeyTH" +
		"eEyqutXlGLaZjDA#wlUeMmukpgpgxegNIYxIyIR#DkkcsdeOVAFM9UJ30VlgNi#b86aMZQG" +
		"oDfN6wjLIqvyVwBT7FCbfkjk8UQumGzrZ8YxMyJ6mPSaKCsQopt8OgHsuxonC$KAP$Af9p2" +
		"XwzmTiRvKh2vroJ#oybyZm4uPbu6myjY$sI9MSsKN0Zv6RWNqaVjkY#QFAC9YRFEeIw7qov" +
		"JXRgLulSX2Xp0dWhy4V0EqEt8VWWbCU25w4y7xmKVTu7hq3vh#3NmRzdmU53bi4VXayjmVy" +
		"CFWVyJVH$7FmJj1y3$XtAaucoiub2xu4t1aTxzgdWQy4xWSDEza3m8U1HS3yunXb2hBBBOH" +
		"$noBuMuuMjx3k80XF1KHUu4lmvy9tnyGVXQyP1YS4xQ7z3OdGk7XEalWlgFqQ$0z8s7kN36" +
		"5UkbEyXgbi7vRFCSjtZCPPfu1XdpYpmiy3$03u0$4DmzC$v5Fm2y7#0hmJ$4lmQy6yH$pTW" +
		"ypLGfk1$7FSti59yQe$njXKPy#Bx7lmgrEssveazPtYDu2q3pbM2TpLi7Y$oCw3RH7uBUF0" +
		"jy4#G4RDt1ED6a#SKe#vX2$Rhqkypo9ZJmEV9zkjkW6tCaUSuOEz6#K6KXrlceW7cVXNg48" +
		"$CDU2OFqAVO0Ve8dSyKy5VHndvaO4uPTu5sGF263AG7$okYUFf3jg6TkIFVp$QlQ0yD7m0Y" +
		"eel1n6pTI8ZvtsoDe81asTYFdphJJaBDlpDH6u7UPx8M9V#HTBlM50TaRE5DnNUIlH7ma#C" +
		"hHxMbGThiru1#2lnyTSpOeDv3EP8BAS3tuToVOdn58ER#tYmeM1Zhw1SUvoz4T4N#zx1eYj" +
		"Z23ON3ll#PyLsH#WjbVefAFT7#KuKiCQ29u9VOxSHH7xN6mUTLo4RlwbxLMp2do3oFLY2Tk" +
		"I#r$1LzgFWHQXRWRWs1yUS#OQ2hmT7Sn1hd8U8tWRXcEiip6jmdyGFwvUsIzitKdSRnY2vb" +
		"uKvzxyjCkOtu16VC8wGp4a8EUR1klFrWepr6Me17xQZ7$QYq8aI2wm3VoVmFS2ed8ipKFu8" +
		"zI#83l8lOwpuyWNwjWQTP9Ozy3iaSn3iYZx8qvnCs0Jt8fT2FQHj1cIiOo$yyCy5lGozHj3" +
		"3sWWD0$KIdx4NPJ8e0tu4KRu2ClRA0FPYxtdWi9s9l0mCHndxNm1rcUU0Zu4kwXYn3lKLh7" +
		"xnEGnWtmwD0fqiSNhCvDwjg5iAmhhpO8xz67SEOXQ2lT08rEq5nxmPeGdr11aw1y3$1CBy1" +
		"bQ3OqyAtGGPiGqjYjlCcIL#P5lpAP6GuflYVQZ8seQFx46qoQclNPSFnUMC3XPPSZBZMk5F" +
		"2lzSvb3MhAUryEk5Rn6#H$XUYLc6SB$mKuIV9douy1BXiezx9LzzibPziaPzBOMVAbpw##u" +
		"Glb7uNVRnKdDxsNUlfMslfNvNWjuFzh9$jqNUB$m3uVA#ZAsDiF0MmkLi4f2zrYk#ShxLXj" +
		"rUeCWYotitCB4gVNjVxmtMCdBdsIfiN58DnbFEzInhF53XW2Uvutr5ociS#ZSIBlj1u6xX3" +
		"mctlaEVDpcDJF3jiBH$Qw#dj#Eo9ngN$OsJ$V2Cj#2jjyXRBFBBYVsg8#ZB6WWyBNo$lJsW" +
		"ymNpyQXPzk4CIdYlq6NYVvx9SwBsVfcszMx1E#ZUjw0deLnNVFvUV8auz6aWVhs4zZjDsMz" +
		"jptFeqrLuD#7Tust#SGxwS#EoRr5oks#bfVzeYxmzBlDp2Ntwsyl#7WdbpMBxDNjze8t5hp" +
		"s9liJRFDsJwu9l2VO#Xp4CiEWTChdt$GITfSRvpkBZFgcNSuJ$8odBNIHGxViYZaCuF$4Wy" +
		"NkQoKEShEURwL3tJ79THkUuxCcqj$4391$rWtfDuIIatjAb0sgl#a1zg3wYs4UjKAlK$Ue#" +
		"IFU2jkgwU$JpRj1wqEqWd6RKhQ1RGEj0DuFm5bMu#QWRGJWLgnj0ruDmWbIuNIdST1Hk3Wf" +
		"lUOKRWC8fILqXLYy7NGR2BL5TedQgHtJj3lryGE5EeXxIygVgOUcnNJZEKceB26SMjHc4Cv" +
		"JQ1C8zJk5EfJQ87ku7wb#g7vvzTNb8RCI3rI0rK0rG$HNE8ggFhZjRF$#ZduSiqS5fIlNMK" +
		"a$r3PwzfFvpzONgeN0FKHTBpMhrfNfGVIRZn6r1oVyPG5sedsLIkaZuAhLCf0hzNAcVvMgv" +
		"6gEbqVevIZz7wkS8$SGPIk7if73sKiF8yb53rK6PvJVryu32VKtjqNNFw#TBwcyATr#5Ewx" +
		"2tKdXxg9mfbHFwzQdzFF961vEJUe9jKkz8cMSfDGVRHOVfwIFUWpqA0ZdS3LBrym4bMXfXd" +
		"vEry$pzNEAcfhGVxBmZzKazOcM9khd1AalriyYMv#eWn$Za#iSjCQ1nggN9Luu7wlTiRO#C" +
		"QbtJEfbwTl3kE$G3bfChF#oOipdCiWLe1da0Vbf9kIPQCCf5SGq6pGHvSdWaw4p2toE9e$#" +
		"TLa9#3pmUU3JmAT1ruYKyTy5J0Kjq7$BoR2GJyYh#KBKBOIy4BPD2iJuNFGtQBhGVA4bcZ9" +
		"a0s5Q3fe0EnDGPrAYx1CAWFp2CtMx#MiEWpm9iZU1CeGybdQ$fRugyjG0#HBAfe$5yBqOPP" +
		"Fy8AFE9t9blK$NBu9kEShba4to2Vc50hG2$gz0sqhKhqIv578fv5Aqczmal850BEKiMrif1" +
		"HFA9asfahmM2b4HV2n2lVcxiaJAaFOC2tbZDEc$RjGzzG==");

    Set<String> types;
    Set<String> preds;

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$global2 = global2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$global2 = lst$global2 global2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$global2 = 
			Action.RETURN,	// [3] opt$lst$global2 = lst$global2
			Action.RETURN,	// [4] unit = opt$lst$global2
			new Action() {	// [5] field = type.t ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new Field(t, n, false);
				}
			},
			new Action() {	// [6] field = UNDERSCORE LPAREN type.t ID.n SEMICOLON RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final String n = (String) _symbol_n.value;
					 return new Field(t, n, true);
				}
			},
			new Action() {	// [7] lst$field = field
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [8] lst$field = lst$field field
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [9] opt$lst$field = 
			Action.RETURN,	// [10] opt$lst$field = lst$field
			Action.RETURN,	// [11] fields = opt$lst$field
			new Action() {	// [12] param = type.t ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new Formal(t, n);
				}
			},
			new Action() {	// [13] params = param
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [14] params = params COMMA param
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [15] const = ID.n
			new Action() {	// [16] consts = const
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [17] consts = consts COMMA const
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [18] exprs = expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [19] exprs = exprs COMMA expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [20] axioms = expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [21] axioms = axioms SEMICOLON expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [22] lst$spec = spec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [23] lst$spec = lst$spec spec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [24] opt$lst$spec = 
			Action.RETURN,	// [25] opt$lst$spec = lst$spec
			Action.RETURN,	// [26] specs = opt$lst$spec
			new Action() {	// [27] global1 = TYPEDEF type.t ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final String n = (String) _symbol_n.value;
					 types.add(n);
                                   return new TypeDef(t, n);
				}
			},
			new Action() {	// [28] global1 = STRUCT ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new StructDecl(n);
				}
			},
			new Action() {	// [29] global1 = UNION ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new UnionDecl(n);
				}
			},
			new Action() {	// [30] global1 = ENUM ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new EnumDecl(n);
				}
			},
			new Action() {	// [31] global1 = STRUCT ID.n LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_fs = _symbols[offset + 4];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return new StructDef(n, fs);
				}
			},
			new Action() {	// [32] global1 = UNION ID.n LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_fs = _symbols[offset + 4];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return new UnionDef(n, fs);
				}
			},
			new Action() {	// [33] global1 = ENUM LBRACE consts.cs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cs = _symbols[offset + 3];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return new EnumDef(cs);
				}
			},
			new Action() {	// [34] global1 = ENUM ID.n LBRACE consts.cs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_cs = _symbols[offset + 4];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return new EnumDef(n, cs);
				}
			},
			new Action() {	// [35] global = global1.g SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_g = _symbols[offset + 1];
					final Global g = (Global) _symbol_g.value;
					 return (Symbol) g;
				}
			},
			new Action() {	// [36] global = type.t ID.n SEMICOLON specs.ss
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ss = _symbols[offset + 4];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Spec[] ss = _list_ss == null ? new Spec[0] : (Spec[]) _list_ss.toArray(new Spec[_list_ss.size()]);
					 return new VarDef(t, n, ss);
				}
			},
			new Action() {	// [37] global = type.t ID.n ASG expr.e SEMICOLON specs.ss
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 6];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Spec[] ss = _list_ss == null ? new Spec[0] : (Spec[]) _list_ss.toArray(new Spec[_list_ss.size()]);
					 return new VarDef(t, n, e, ss);
				}
			},
			new Action() {	// [38] global = type.t ID.n LPAREN RPAREN SEMICOLON specs.ss
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ss = _symbols[offset + 6];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Spec[] ss = _list_ss == null ? new Spec[0] : (Spec[]) _list_ss.toArray(new Spec[_list_ss.size()]);
					 return new FunDef(t, n, ss);
				}
			},
			new Action() {	// [39] global = type.t ID.n LPAREN params.xs RPAREN SEMICOLON specs.ss
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_xs = _symbols[offset + 4];
					final ArrayList _list_xs = (ArrayList) _symbol_xs.value;
					final Formal[] xs = _list_xs == null ? new Formal[0] : (Formal[]) _list_xs.toArray(new Formal[_list_xs.size()]);
					final Symbol _symbol_ss = _symbols[offset + 7];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Spec[] ss = _list_ss == null ? new Spec[0] : (Spec[]) _list_ss.toArray(new Spec[_list_ss.size()]);
					 return new FunDef(t, n, xs, ss);
				}
			},
			new Action() {	// [40] global = type.t ID.n LPAREN RPAREN specs.ss local1.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Spec[] ss = _list_ss == null ? new Spec[0] : (Spec[]) _list_ss.toArray(new Spec[_list_ss.size()]);
					final Symbol _symbol_b = _symbols[offset + 6];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new FunDef(t, n, ss, b);
				}
			},
			new Action() {	// [41] global = type.t ID.n LPAREN params.xs RPAREN specs.ss local1.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_xs = _symbols[offset + 4];
					final ArrayList _list_xs = (ArrayList) _symbol_xs.value;
					final Formal[] xs = _list_xs == null ? new Formal[0] : (Formal[]) _list_xs.toArray(new Formal[_list_xs.size()]);
					final Symbol _symbol_ss = _symbols[offset + 6];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Spec[] ss = _list_ss == null ? new Spec[0] : (Spec[]) _list_ss.toArray(new Spec[_list_ss.size()]);
					final Symbol _symbol_b = _symbols[offset + 7];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new FunDef(t, n, xs, ss, b);
				}
			},
			Action.RETURN,	// [42] global2 = global
			new Action() {	// [43] global2 = aux.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Aux a = (Aux) _symbol_a.value;
					 return new Ghost(a);
				}
			},
			new Action() {	// [44] local = SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Block.empty();
				}
			},
			Action.RETURN,	// [45] local = local1
			Action.RETURN,	// [46] local2 = local1
			new Action() {	// [47] local2 = aux.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Aux a = (Aux) _symbol_a.value;
					 return new Ghost(a);
				}
			},
			new Action() {	// [48] lst$local2 = local2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [49] lst$local2 = lst$local2 local2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [50] opt$lst$local2 = 
			Action.RETURN,	// [51] opt$lst$local2 = lst$local2
			Action.RETURN,	// [52] locals2 = opt$lst$local2
			new Action() {	// [53] local1 = LBRACE locals2.ss RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ss = _symbols[offset + 2];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Stmt[] ss = _list_ss == null ? new Stmt[0] : (Stmt[]) _list_ss.toArray(new Stmt[_list_ss.size()]);
					 return new Block(ss);
				}
			},
			new Action() {	// [54] local1 = expr.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new Atomic(a);
				}
			},
			new Action() {	// [55] local1 = RETURN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Return.none();
				}
			},
			new Action() {	// [56] local1 = RETURN expr.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new Return(a);
				}
			},
			new Action() {	// [57] local1 = BREAK SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Break.self();
				}
			},
			new Action() {	// [58] local1 = CONTINUE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Continue.self();
				}
			},
			new Action() {	// [59] local1 = type.t ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new VarDef(t, n);
				}
			},
			new Action() {	// [60] local1 = type.t ID.n ASG expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new VarDef(t, n, e);
				}
			},
			new Action() {	// [61] local1 = IF LPAREN expr.a RPAREN local.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new If(a, b);
				}
			},
			new Action() {	// [62] local1 = IF LPAREN expr.a RPAREN local.b ELSE local.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Stmt b = (Stmt) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Stmt c = (Stmt) _symbol_c.value;
					 return new If(a, b, c);
				}
			},
			new Action() {	// [63] local1 = WHILE LPAREN expr.a RPAREN specs.ss local.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Spec[] ss = _list_ss == null ? new Spec[0] : (Spec[]) _list_ss.toArray(new Spec[_list_ss.size()]);
					final Symbol _symbol_b = _symbols[offset + 6];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new While(a, ss, b);
				}
			},
			new Action() {	// [64] local1 = DO local.b WHILE LPAREN expr.a RPAREN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final Expr a = (Expr) _symbol_a.value;
					 return new DoWhile(b, a);
				}
			},
			new Action() {	// [65] local1 = FOR LPAREN expr.a SEMICOLON expr.b SEMICOLON expr.c SEMICOLON RPAREN local.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Expr b = (Expr) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol _symbol_p = _symbols[offset + 10];
					final Stmt p = (Stmt) _symbol_p.value;
					 return new For(a, b, c, p);
				}
			},
			new Action() {	// [66] local1 = error SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Malformed.self();
				}
			},
			Action.RETURN,	// [67] expr = PREFIX
			Action.RETURN,	// [68] expr = POSTFIX
			new Action() {	// [69] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return (Symbol) e;
				}
			},
			new Action() {	// [70] expr = ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Id(n);
				}
			},
			new Action() {	// [71] expr = NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					 return new Lit(n);
				}
			},
			new Action() {	// [72] expr = ID.n LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new FunCall(n, new Expr[]{});
				}
			},
			new Action() {	// [73] expr = ID.n LPAREN exprs.as RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_as = _symbols[offset + 3];
					final ArrayList _list_as = (ArrayList) _symbol_as.value;
					final Expr[] as = _list_as == null ? new Expr[0] : (Expr[]) _list_as.toArray(new Expr[_list_as.size()]);
					 return new FunCall(n, as);
				}
			},
			new Action() {	// [74] expr = OLD LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new Old(e);
				}
			},
			new Action() {	// [75] expr = LPAREN type.t RPAREN expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Cast(t, (Expr)a);
				}
			},
			new Action() {	// [76] expr = SIZEOF LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new SizeOfExpr((Expr)e);
				}
			},
			new Action() {	// [77] expr = expr.a INCR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new PostOp("++", a);
				}
			},
			new Action() {	// [78] expr = expr.a DECR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new PostOp("--", a);
				}
			},
			new Action() {	// [79] expr = expr.a ARROW ID.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					 return new Arrow(a, f);
				}
			},
			new Action() {	// [80] expr = expr.a DOT ID.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					 return new Dot(a, f);
				}
			},
			new Action() {	// [81] expr = expr.a LBRACK expr.i RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final Expr i = (Expr) _symbol_i.value;
					 return new Index(a, i);
				}
			},
			new Action() {	// [82] expr = expr.a LBRACK expr.b COLONEQ expr.c RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Expr c = (Expr) _symbol_c.value;
					 return new Update(a, b, c);
				}
			},
			new Action() {	// [83] expr = INCR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("++", a);
				}
			},
			new Action() {	// [84] expr = DECR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("--", a);
				}
			},
			new Action() {	// [85] expr = PLUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("+", a);
				}
			},
			new Action() {	// [86] expr = MINUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("-", a);
				}
			},
			new Action() {	// [87] expr = BANG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("!", a);
				}
			},
			new Action() {	// [88] expr = TILDE expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("~", a);
				}
			},
			new Action() {	// [89] expr = STAR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("*", a);
				}
			},
			new Action() {	// [90] expr = AMP expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("&", a);
				}
			},
			new Action() {	// [91] expr = expr.a STAR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("*", a, b);
				}
			},
			new Action() {	// [92] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("/", a, b);
				}
			},
			new Action() {	// [93] expr = expr.a MOD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("%", a, b);
				}
			},
			new Action() {	// [94] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("+", a, b);
				}
			},
			new Action() {	// [95] expr = expr.a MINUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("-", a, b);
				}
			},
			new Action() {	// [96] expr = expr.a SHL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("<<",a, b);
				}
			},
			new Action() {	// [97] expr = expr.a SHR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(">>",a, b);
				}
			},
			new Action() {	// [98] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("<", a, b);
				}
			},
			new Action() {	// [99] expr = expr.a LE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("<=",a, b);
				}
			},
			new Action() {	// [100] expr = expr.a GE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(">=",a, b);
				}
			},
			new Action() {	// [101] expr = expr.a GT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(">", a, b);
				}
			},
			new Action() {	// [102] expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("==",a, b);
				}
			},
			new Action() {	// [103] expr = expr.a NEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("!=",a, b);
				}
			},
			new Action() {	// [104] expr = expr.a AMP expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("&", a, b);
				}
			},
			new Action() {	// [105] expr = expr.a CARET expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("^", a, b);
				}
			},
			new Action() {	// [106] expr = expr.a PIPE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("|", a, b);
				}
			},
			new Action() {	// [107] expr = expr.a DCOLON expr.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final Expr l = (Expr) _symbol_l.value;
					 return new BinOp("::", a, l);
				}
			},
			new Action() {	// [108] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("&&",a, b);
				}
			},
			new Action() {	// [109] expr = expr.a OR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("||",a, b);
				}
			},
			new Action() {	// [110] expr = expr.a IMP expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("==>",a, b);
				}
			},
			new Action() {	// [111] expr = expr.a EQV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("<=>",a, b);
				}
			},
			new Action() {	// [112] expr = expr.a QUESTION expr.b COLON expr.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Expr c = (Expr) _symbol_c.value;
					 return new Question(a, b, c);
				}
			},
			new Action() {	// [113] expr = expr.a ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("=", a, b);
				}
			},
			new Action() {	// [114] expr = expr.a ASG_OP.e expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final String e = (String) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("=", a, new BinOp(e.substring(0, e.length() - 1), a, b));
				}
			},
			new Action() {	// [115] expr = expr.a COMMA expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(",", a, b);
				}
			},
			new Action() {	// [116] expr = FORALL params.ps DOT expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ps = _symbols[offset + 2];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final Formal[] ps = _list_ps == null ? new Formal[0] : (Formal[]) _list_ps.toArray(new Formal[_list_ps.size()]);
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Bind("forall", ps, a);
				}
			},
			new Action() {	// [117] expr = EXISTS params.ps DOT expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ps = _symbols[offset + 2];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final Formal[] ps = _list_ps == null ? new Formal[0] : (Formal[]) _list_ps.toArray(new Formal[_list_ps.size()]);
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Bind("exists", ps, a);
				}
			},
			Action.RETURN,	// [118] assert = expr
			new Action() {	// [119] assert = LPAREN assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Assert a = (Assert) _symbol_a.value;
					 return (Symbol) a;
				}
			},
			new Action() {	// [120] assert = expr.p PTO expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					 return new PointsTo((Expr)p, (Expr)a);
				}
			},
			new Action() {	// [121] assert = expr.p PTO LBRACK expr.l RBRACK expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final Expr l = (Expr) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 6];
					final Expr a = (Expr) _symbol_a.value;
					 return new PointsTo((Expr)p, (Expr)l, (Expr)a);
				}
			},
			new Action() {	// [122] assert = PRED.n LPAREN exprs.in RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_in = _symbols[offset + 3];
					final ArrayList _list_in = (ArrayList) _symbol_in.value;
					final Expr[] in = _list_in == null ? new Expr[0] : (Expr[]) _list_in.toArray(new Expr[_list_in.size()]);
					 return new Chunk(n, in);
				}
			},
			new Action() {	// [123] assert = PRED.n LPAREN SEMICOLON exprs.out RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_out = _symbols[offset + 4];
					final ArrayList _list_out = (ArrayList) _symbol_out.value;
					final Expr[] out = _list_out == null ? new Expr[0] : (Expr[]) _list_out.toArray(new Expr[_list_out.size()]);
					 return new Chunk(n, new Expr[]{}, out);
				}
			},
			new Action() {	// [124] assert = PRED.n LPAREN exprs.in SEMICOLON exprs.out RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_in = _symbols[offset + 3];
					final ArrayList _list_in = (ArrayList) _symbol_in.value;
					final Expr[] in = _list_in == null ? new Expr[0] : (Expr[]) _list_in.toArray(new Expr[_list_in.size()]);
					final Symbol _symbol_out = _symbols[offset + 5];
					final ArrayList _list_out = (ArrayList) _symbol_out.value;
					final Expr[] out = _list_out == null ? new Expr[0] : (Expr[]) _list_out.toArray(new Expr[_list_out.size()]);
					 return new Chunk(n, in, out);
				}
			},
			new Action() {	// [125] assert = assert.a AND assert.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Assert a = (Assert) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Assert b = (Assert) _symbol_b.value;
					 return new And(a, b);
				}
			},
			new Action() {	// [126] assert = expr.a IMP assert.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Assert b = (Assert) _symbol_b.value;
					 return new Cond(a, b);
				}
			},
			new Action() {	// [127] assert = expr.a QUESTION assert.b COLON assert.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Assert b = (Assert) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Assert c = (Assert) _symbol_c.value;
					 return new Cond(a, b, c);
				}
			},
			new Action() {	// [128] assert = EXISTS params.ex DOT assert.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 2];
					final ArrayList _list_ex = (ArrayList) _symbol_ex.value;
					final Formal[] ex = _list_ex == null ? new Formal[0] : (Formal[]) _list_ex.toArray(new Formal[_list_ex.size()]);
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Exists(ex, a);
				}
			},
			new Action() {	// [129] predid = ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 preds.add(n); return _symbol_n;
				}
			},
			new Action() {	// [130] preddef = predid.n LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new PredDef(n);
				}
			},
			new Action() {	// [131] preddef = predid.n LPAREN RPAREN assert.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new PredDef(n, a);
				}
			},
			new Action() {	// [132] preddef = predid.n LPAREN params.in RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_in = _symbols[offset + 3];
					final ArrayList _list_in = (ArrayList) _symbol_in.value;
					final Formal[] in = _list_in == null ? new Formal[0] : (Formal[]) _list_in.toArray(new Formal[_list_in.size()]);
					 return new PredDef(n, in);
				}
			},
			new Action() {	// [133] preddef = predid.n LPAREN params.in RPAREN assert.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_in = _symbols[offset + 3];
					final ArrayList _list_in = (ArrayList) _symbol_in.value;
					final Formal[] in = _list_in == null ? new Formal[0] : (Formal[]) _list_in.toArray(new Formal[_list_in.size()]);
					final Symbol _symbol_a = _symbols[offset + 5];
					final Assert a = (Assert) _symbol_a.value;
					 return new PredDef(n, in, a);
				}
			},
			new Action() {	// [134] preddef = predid.n LPAREN SEMICOLON params.out RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_out = _symbols[offset + 4];
					final ArrayList _list_out = (ArrayList) _symbol_out.value;
					final Formal[] out = _list_out == null ? new Formal[0] : (Formal[]) _list_out.toArray(new Formal[_list_out.size()]);
					 return new PredDef(n, new Formal[]{}, out);
				}
			},
			new Action() {	// [135] preddef = predid.n LPAREN SEMICOLON params.out RPAREN assert.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_out = _symbols[offset + 4];
					final ArrayList _list_out = (ArrayList) _symbol_out.value;
					final Formal[] out = _list_out == null ? new Formal[0] : (Formal[]) _list_out.toArray(new Formal[_list_out.size()]);
					final Symbol _symbol_a = _symbols[offset + 6];
					final Assert a = (Assert) _symbol_a.value;
					 return new PredDef(n, new Formal[]{}, out, a);
				}
			},
			new Action() {	// [136] preddef = predid.n LPAREN params.in SEMICOLON params.out RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_in = _symbols[offset + 3];
					final ArrayList _list_in = (ArrayList) _symbol_in.value;
					final Formal[] in = _list_in == null ? new Formal[0] : (Formal[]) _list_in.toArray(new Formal[_list_in.size()]);
					final Symbol _symbol_out = _symbols[offset + 5];
					final ArrayList _list_out = (ArrayList) _symbol_out.value;
					final Formal[] out = _list_out == null ? new Formal[0] : (Formal[]) _list_out.toArray(new Formal[_list_out.size()]);
					 return new PredDef(n, in, out);
				}
			},
			new Action() {	// [137] preddef = predid.n LPAREN params.in SEMICOLON params.out RPAREN assert.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_in = _symbols[offset + 3];
					final ArrayList _list_in = (ArrayList) _symbol_in.value;
					final Formal[] in = _list_in == null ? new Formal[0] : (Formal[]) _list_in.toArray(new Formal[_list_in.size()]);
					final Symbol _symbol_out = _symbols[offset + 5];
					final ArrayList _list_out = (ArrayList) _symbol_out.value;
					final Formal[] out = _list_out == null ? new Formal[0] : (Formal[]) _list_out.toArray(new Formal[_list_out.size()]);
					final Symbol _symbol_a = _symbols[offset + 7];
					final Assert a = (Assert) _symbol_a.value;
					 return new PredDef(n, in, out, a);
				}
			},
			new Action() {	// [138] pureconstdef = type.t ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new PureDef(n, t);
				}
			},
			new Action() {	// [139] pureconstdef = type.t ID.n ASG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new PureDef(n, t, a);
				}
			},
			new Action() {	// [140] puredef = type.t ID.n LPAREN params.ps RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ps = _symbols[offset + 4];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final Formal[] ps = _list_ps == null ? new Formal[0] : (Formal[]) _list_ps.toArray(new Formal[_list_ps.size()]);
					 return new PureDef(n, ps, t);
				}
			},
			new Action() {	// [141] puredef = type.t ID.n LPAREN params.ps RPAREN ASG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ps = _symbols[offset + 4];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final Formal[] ps = _list_ps == null ? new Formal[0] : (Formal[]) _list_ps.toArray(new Formal[_list_ps.size()]);
					final Symbol _symbol_a = _symbols[offset + 7];
					final Expr a = (Expr) _symbol_a.value;
					 return new PureDef(n, ps, t, a);
				}
			},
			new Action() {	// [142] aux = UNDERSCORE LPAREN PRUNE RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Prune.self();
				}
			},
			new Action() {	// [143] aux = UNDERSCORE LPAREN ASSERT assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Consume(a, "assert");
				}
			},
			new Action() {	// [144] aux = UNDERSCORE LPAREN ASSERT assert.a STRING.m RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					final Symbol _symbol_m = _symbols[offset + 5];
					final String m = (String) _symbol_m.value;
					 return new Consume(a, m);
				}
			},
			new Action() {	// [145] aux = UNDERSCORE LPAREN ASSUME assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Produce(a);
				}
			},
			new Action() {	// [146] aux = UNDERSCORE LPAREN UNFOLD assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Unfold(a);
				}
			},
			new Action() {	// [147] aux = UNDERSCORE LPAREN FOLD assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Fold(a);
				}
			},
			Action.NONE,  	// [148] opt$APPLY = 
			Action.RETURN,	// [149] opt$APPLY = APPLY
			new Action() {	// [150] aux = UNDERSCORE LPAREN opt$APPLY local1.b RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 4];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new Apply(b);
				}
			},
			new Action() {	// [151] aux = UNDERSCORE LPAREN APPLY FORALL params.ps DOT ID.n LPAREN exprs.as RPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ps = _symbols[offset + 5];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final Formal[] ps = _list_ps == null ? new Formal[0] : (Formal[]) _list_ps.toArray(new Formal[_list_ps.size()]);
					final Symbol _symbol_n = _symbols[offset + 7];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_as = _symbols[offset + 9];
					final ArrayList _list_as = (ArrayList) _symbol_as.value;
					final Expr[] as = _list_as == null ? new Expr[0] : (Expr[]) _list_as.toArray(new Expr[_list_as.size()]);
					 return new ApplyForall(ps, new FunCall(n, as));
				}
			},
			new Action() {	// [152] aux = UNDERSCORE LPAREN REWRITES axioms.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final Expr[] a = _list_a == null ? new Expr[0] : (Expr[]) _list_a.toArray(new Expr[_list_a.size()]);
					 return new Rules(a,false);
				}
			},
			new Action() {	// [153] aux = UNDERSCORE LPAREN AXIOMS axioms.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final Expr[] a = _list_a == null ? new Expr[0] : (Expr[]) _list_a.toArray(new Expr[_list_a.size()]);
					 return new Rules(a,true);
				}
			},
			new Action() {	// [154] aux = UNDERSCORE LPAREN LEMMA expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new Lemma(e);
				}
			},
			new Action() {	// [155] aux = UNDERSCORE LPAREN LEMMA expr.e SEMICOLON INDUCT ID.n RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_n = _symbols[offset + 7];
					final String n = (String) _symbol_n.value;
					 return new Lemma(e, new Id(n));
				}
			},
			new Action() {	// [156] aux = UNDERSCORE LPAREN CONSTANT pureconstdef.p RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 4];
					final PureDef p = (PureDef) _symbol_p.value;
					 return p;
				}
			},
			new Action() {	// [157] aux = UNDERSCORE LPAREN FUNCTION puredef.p RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 4];
					final PureDef p = (PureDef) _symbol_p.value;
					 return p;
				}
			},
			new Action() {	// [158] aux = UNDERSCORE LPAREN PREDICATE preddef.p RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 4];
					final PredDef p = (PredDef) _symbol_p.value;
					 return p;
				}
			},
			new Action() {	// [159] aux = UNDERSCORE LPAREN ATOMIC BEGIN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return BeginAtomicBlock.self();
				}
			},
			new Action() {	// [160] aux = UNDERSCORE LPAREN ATOMIC END RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return EndAtomicBlock.self();
				}
			},
			new Action() {	// [161] spec = UNDERSCORE LPAREN REQUIRES assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Requires(a);
				}
			},
			new Action() {	// [162] spec = UNDERSCORE LPAREN ENSURES assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Ensures(a);
				}
			},
			new Action() {	// [163] spec = UNDERSCORE LPAREN INVARIANT assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Invariant(a);
				}
			},
			new Action() {	// [164] spec = UNDERSCORE LPAREN RESOURCE assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Resource(a);
				}
			},
			new Action() {	// [165] spec = UNDERSCORE LPAREN MAINTAINS assert.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					 return new Maintains(a);
				}
			},
			new Action() {	// [166] spec = UNDERSCORE LPAREN FAILS ID.m RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_m = _symbols[offset + 4];
					final String m = (String) _symbol_m.value;
					 return new Fails(m);
				}
			},
			new Action() {	// [167] spec = UNDERSCORE LPAREN LEMMA RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Lemma.self();
				}
			},
			new Action() {	// [168] spec = UNDERSCORE LPAREN PURE RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return PureSpec.self();
				}
			},
			new Action() {	// [169] spec = UNDERSCORE LPAREN ATOMIC RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return AtomicSpec.self();
				}
			},
			new Action() {	// [170] spec = UNDERSCORE LPAREN SHARED assert.a RELY expr.b GUARANTEE expr.c RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 4];
					final Assert a = (Assert) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final Expr b = (Expr) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 8];
					final Expr c = (Expr) _symbol_c.value;
					 return new Shared(a, b, c);
				}
			},
			new Action() {	// [171] type = LIST_LT type.t GT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					 return new Type.list(t);
				}
			},
			new Action() {	// [172] type = MAP_LT type.d COMMA type.r GT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_d = _symbols[offset + 2];
					final Type d = (Type) _symbol_d.value;
					final Symbol _symbol_r = _symbols[offset + 4];
					final Type r = (Type) _symbol_r.value;
					 return new Type.array(d, r);
				}
			},
			new Action() {	// [173] type = VOID
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Void.self();
				}
			},
			new Action() {	// [174] type = INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return SignedInt.self();
				}
			},
			new Action() {	// [175] type = CHAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return SignedChar.self();
				}
			},
			new Action() {	// [176] type = PARAM.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					 return new Type.param(p);
				}
			},
			new Action() {	// [177] type = TYPE.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					 return new TypedefName(t);
				}
			},
			new Action() {	// [178] type = type.t STAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					 return new PtrType(t);
				}
			},
			new Action() {	// [179] type = type.t LBRACK RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					 return new PtrType(t);
				}
			},
			new Action() {	// [180] type = STRUCT ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return new StructName(t);
				}
			},
			new Action() {	// [181] type = UNION ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return new UnionName(t);
				}
			},
			new Action() {	// [182] type = ENUM ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return new EnumName(t);
				}
			},
			new Action() {	// [183] type = STRUCT LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fs = _symbols[offset + 3];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return new AnonStruct(fs);
				}
			},
			new Action() {	// [184] type = UNION LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fs = _symbols[offset + 3];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return new AnonUnion(fs);
				}
			},
			new Action() {	// [185] type = ENUM LBRACE consts.cs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cs = _symbols[offset + 3];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return new AnonEnum(cs);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
